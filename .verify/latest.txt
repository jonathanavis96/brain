Ralph Verifier Report
Time: 2026-01-21 23:42:33
Git:  8556749
AC:   /home/grafe/code/brain/rules/AC.rules
Approvals: /home/grafe/code/brain/rules/MANUAL_APPROVALS.rules
------------------------------------------------------------
[PASS] BugA.1
  desc: Parser uses in_task_section state tracking
  cmd:  grep -c 'in_task_section=false' current_ralph_tasks.sh
  exit: 0
  stdout: 8
[PASS] BugA.2
  desc: Parser checks for ## (major section) not ### subsections
  cmd:  grep -E '^\s*elif.*\^\#\#\[' current_ralph_tasks.sh | grep -v '###' | wc -l | tr -d ' '
  exit: 0
  stdout: 1
[PASS] BugB.1
  desc: Display function uses clear for full redraw
  cmd:  grep -c 'clear' current_ralph_tasks.sh
  exit: 0
  stdout: 5
[PASS] BugB.2
  desc: No differential update logic (LAST_RENDERED)
  cmd:  grep -c 'LAST_RENDERED' current_ralph_tasks.sh
  exit: 1
  stdout: 0
[WARN] BugB.UI.1 (manual review)
  desc: No visual corruption after terminal resize
  instructions: Run current_ralph_tasks.sh, resize terminal, confirm display remains intact
[PASS] BugC.1
  desc: No scan_for_new_completions function
  cmd:  grep -c 'scan_for_new_completions' thunk_ralph_tasks.sh
  exit: 1
  stdout: 0
[PASS] BugC.2
  desc: No PLAN_FILE variable
  cmd:  grep -c '^PLAN_FILE=' thunk_ralph_tasks.sh
  exit: 1
  stdout: 0
[PASS] BugC.3
  desc: No "Scanning IMPLEMENTATION_PLAN" message
  cmd:  grep -c 'Scanning IMPLEMENTATION_PLAN' thunk_ralph_tasks.sh
  exit: 1
  stdout: 0
[PASS] BugC.4
  desc: Monitor references THUNK.md
  cmd:  grep -c 'THUNK\.md' thunk_ralph_tasks.sh
  exit: 0
  stdout: 9
[PASS] BugC.5
  desc: Monitor does not append/redirect into THUNK.md
  cmd:  grep -nE '>>\s*.*THUNK\.md|>\s*.*THUNK\.md' thunk_ralph_tasks.sh | wc -l | tr -d ' '
  exit: 0
  stdout: 0
[PASS] BugC.6
  desc: No task_exists_in_thunk function
  cmd:  grep -c 'task_exists_in_thunk' thunk_ralph_tasks.sh
  exit: 1
  stdout: 0
[PASS] BugC.7
  desc: No extract_task_id function
  cmd:  grep -c 'extract_task_id' thunk_ralph_tasks.sh
  exit: 1
  stdout: 0
[WARN] BugC.UI.1 (manual review)
  desc: THUNK monitor only displays, never modifies files
  instructions: Run thunk_ralph_tasks.sh, mark a task [x] in IMPLEMENTATION_PLAN.md, confirm THUNK.md is NOT auto-updated
[WARN] Template.1 (auto check failed but warn gate)
  desc: thunk_ralph_tasks.sh matches template
  cmd:  diff -q thunk_ralph_tasks.sh templates/ralph/thunk_ralph_tasks.sh 2>/dev/null && echo "match" || echo "differ"
  exit: 0
  stdout: differ
  reasons:
    - stdout mismatch expected='match' got='differ'
[PASS] AntiCheat.1
  desc: No fake verification markers in source files
  cmd:  grep -RIn --include='*.sh' --include='*.md' --exclude-dir=.git --exclude-dir=.verify --exclude-dir=logs --exclude-dir=old_md --exclude='AC.rules' --exclude='IMPLEMENTATION_PLAN.md' "<!-- verified" . 2>/dev/null | wc -l | tr -d ' '
  exit: 0
  stdout: 0
[PASS] AntiCheat.2
  desc: No dismissal phrases in active source files
  cmd:  grep -RIn --include='*.sh' --include='*.md' --exclude-dir=.git --exclude-dir=.verify --exclude-dir=logs --exclude-dir=old_md --exclude='AC.rules' --exclude='PROMPT.md' --exclude='IMPLEMENTATION_PLAN.md' "by design" . 2>/dev/null | wc -l | tr -d ' '
  exit: 0
  stdout: 0
[PASS] AntiCheat.3
  desc: No bug reframing in source files
  cmd:  grep -RIn --include='*.sh' --include='*.md' --exclude-dir=.git --exclude-dir=.verify --exclude-dir=logs --exclude-dir=old_md --exclude='AC.rules' --exclude='IMPLEMENTATION_PLAN.md' "feature, not a bug" . 2>/dev/null | wc -l | tr -d ' '
  exit: 0
  stdout: 0
[PASS] AntiCheat.4
  desc: No intended behavior dismissals in source files
  cmd:  grep -RIn --include='*.sh' --include='*.md' --exclude-dir=.git --exclude-dir=.verify --exclude-dir=logs --exclude-dir=old_md --exclude='AC.rules' --exclude='IMPLEMENTATION_PLAN.md' "works as intended" . 2>/dev/null | wc -l | tr -d ' '
  exit: 0
  stdout: 0
[PASS] AntiCheat.5
  desc: No self-certification in source files
  cmd:  grep -RIn --include='*.sh' --include='*.md' --exclude-dir=.git --exclude-dir=.verify --exclude-dir=logs --exclude-dir=old_md --exclude='AC.rules' --exclude='IMPLEMENTATION_PLAN.md' "verified: this is" . 2>/dev/null | wc -l | tr -d ' '
  exit: 0
  stdout: 0
[PASS] Protected.1
  desc: loop.sh unchanged from baseline
  cmd:  sha256sum loop.sh | cut -d' ' -f1 | diff -q - ../.verify/loop.sha256 >/dev/null 2>&1 && echo "match" || echo "mismatch"
  exit: 0
  stdout: match
[PASS] Protected.2
  desc: verifier.sh unchanged from baseline
  cmd:  sha256sum verifier.sh | cut -d' ' -f1 | diff -q - ../.verify/verifier.sha256 >/dev/null 2>&1 && echo "match" || echo "mismatch"
  exit: 0
  stdout: match
[FAIL] Protected.3
  desc: PROMPT.md unchanged from baseline
  cmd:  sha256sum PROMPT.md | cut -d' ' -f1 | diff -q - ../.verify/prompt.sha256 >/dev/null 2>&1 && echo "match" || echo "mismatch"
  exit: 0
  stdout: mismatch
  reasons:
    - stdout mismatch expected='match' got='mismatch'
[PASS] VerifyMeta.1
  desc: Verifier run_id.txt exists and is non-empty
  cmd:  test -s ../.verify/run_id.txt && echo "OK" || echo "FAIL"
  exit: 0
  stdout: OK
[WARN] BugB.Auto.1 (auto check in warn gate)
  desc: Display uses terminal-safe cursor positioning (tput)
  cmd:  grep -c 'tput\|printf.*\\033' current_ralph_tasks.sh
  exit: 0
  stdout: 3
[WARN] BugB.Auto.2 (auto check in warn gate)
  desc: Display has stty handling for terminal state
  cmd:  grep -c 'stty' current_ralph_tasks.sh
  exit: 0
  stdout: 2
[PASS] BugC.Auto.1
  desc: THUNK monitor has no auto-sync from IMPLEMENTATION_PLAN
  cmd:  grep -c 'IMPLEMENTATION_PLAN\|PLAN_FILE' thunk_ralph_tasks.sh
  exit: 1
  stdout: 0
[WARN] BugC.Auto.2 (auto check in warn gate)
  desc: THUNK writes limited to era creation only
  cmd:  grep -nE '>>\s*.*THUNK|>\s*.*THUNK' thunk_ralph_tasks.sh | grep -v 'new.*era\|Era:' | wc -l | tr -d ' '
  exit: 0
  stdout: 0
[WARN] Hygiene.Shellcheck.1 (auto check in warn gate)
  desc: No unused variables in current_ralph_tasks.sh (SC2034)
  cmd:  shellcheck -f gcc current_ralph_tasks.sh 2>/dev/null | grep -c 'SC2034' || true
  exit: 0
  stdout: 0
[WARN] Hygiene.Shellcheck.2 (auto check in warn gate)
  desc: No SC2155 issues in current_ralph_tasks.sh (local var masking)
  cmd:  shellcheck -f gcc current_ralph_tasks.sh 2>/dev/null | grep -c 'SC2155' || true
  exit: 0
  stdout: 0
[WARN] Hygiene.Shellcheck.3 (auto check in warn gate)
  desc: No unused variables in thunk_ralph_tasks.sh (SC2034)
  cmd:  shellcheck -f gcc thunk_ralph_tasks.sh 2>/dev/null | grep -c 'SC2034' || true
  exit: 0
  stdout: 0
[WARN] Hygiene.Shellcheck.4 (auto check in warn gate)
  desc: No SC2155 issues in thunk_ralph_tasks.sh (local var masking)
  cmd:  shellcheck -f gcc thunk_ralph_tasks.sh 2>/dev/null | grep -c 'SC2155' || true
  exit: 0
  stdout: 0
[WARN] Hygiene.TermSync.1 (auto check in warn gate)
  desc: No stale 'kb/' references in active markdown (migration complete)
  cmd:  rg -l '\bkb/' --include='*.md' --glob='!HISTORY.md' --glob='!CHANGES.md' --glob='!old_md/*' . 2>/dev/null | wc -l | tr -d ' '
  exit: 0
  stdout: 0
[WARN] Hygiene.TermSync.2 (auto check in warn gate)
  desc: No "Brain KB" terminology (should be "Brain Skills")
  cmd:  rg -c 'Brain KB' --include='*.md' --glob='!HISTORY.md' --glob='!CHANGES.md' . 2>/dev/null | wc -l | tr -d ' '
  exit: 0
  stdout: 0
[WARN] Hygiene.TermSync.3 (auto check in warn gate)
  desc: No "KB file" terminology (should be "skill file")
  cmd:  rg -c 'KB file' --include='*.md' --glob='!HISTORY.md' --glob='!CHANGES.md' . 2>/dev/null | wc -l | tr -d ' '
  exit: 0
  stdout: 0
[WARN] Hygiene.TemplateSync.1 (auto check failed but warn gate)
  desc: current_ralph_tasks.sh matches template
  cmd:  diff -q current_ralph_tasks.sh templates/ralph/current_ralph_tasks.sh 2>/dev/null && echo "match" || echo "differ"
  exit: 0
  stdout: differ
  reasons:
    - stdout mismatch expected='match' got='differ'
[WARN] Hygiene.TemplateSync.2 (auto check failed but warn gate)
  desc: loop.sh core logic matches template (excluding hashes)
  cmd:  diff <(grep -v 'sha256\|MODEL_' loop.sh) <(grep -v 'sha256\|MODEL_' templates/ralph/loop.sh) 2>/dev/null && echo "match" || echo "differ"
  exit: 0
  stdout: 1,1054d0
< #!/usr/bin/env bash
< set -euo pipefail
<
< # ROOT can be overridden via env var for project delegation
< if [[ -n "${RALPH_PROJECT_ROOT:-}" ]]; then
<   ROOT="$RALPH_PROJECT_ROOT"
<   RALPH="$ROOT/workers/ralph"
< else
<   ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")/../.." && pwd)"
<   RALPH="$ROOT/workers/ralph"
< fi
< LOGDIR="$RALPH/logs"
< mkdir -p "$LOGDIR"
<
< # Configurable Brain repo for commit trailers
< BRAIN_REPO="${BRAIN_REPO:-jonathanavis96/brain}"
<
< # Derive clean branch name from git repo name
< # Derive repo name from git remote (stable across machines) or fall back to folder name
< # Use git -C "$ROOT" to ensure commands run against the intended project directory
< if git -C "$ROOT" remote get-url origin &>/dev/null; then
<   REPO_NAME=$(basename -s .git "$(git -C "$ROOT" remote get-url origin)")
< else
<   REPO_NAME=$(basename "$ROOT")
< fi
< WORK_BRANCH="${REPO_NAME}-work"
<
< # Lock file to prevent concurrent runs
< # Lock file includes hash of repo path for uniqueness across same-named repos
< REPO_PATH_HASH=$(cd "$ROOT" && pwd | md5sum | cut -c1-8)
< LOCK_FILE="/tmp/ralph-${REPO_NAME}-${REPO_PATH_HASH}.lock"
<
< # TARGET_BRANCH will be set after arg parsing (uses BRANCH_ARG if provided, else WORK_BRANCH)
<
< # Check if a PID is still running
< is_pid_running() {
<   local pid="$1"
<   if [[ -z "$pid" || "$pid" == "unknown" ]]; then
<     return 1  # Invalid PID, treat as not running
<   fi
<   # Check if process exists (works on Linux/macOS)
<   kill -0 "$pid" 2>/dev/null
< }
<
< # Atomic lock acquisition with stale lock detection
< acquire_lock() {
<   # First, check for stale lock
<   if [[ -f "$LOCK_FILE" ]]; then
<     LOCK_PID=$(cat "$LOCK_FILE" 2>/dev/null || echo "unknown")
<     if ! is_pid_running "$LOCK_PID"; then
<       echo "ðŸ§¹ Removing stale lock (PID $LOCK_PID no longer running)"
<       rm -f "$LOCK_FILE"
<     fi
<   fi
<
<   if command -v flock &>/dev/null; then
<     # Use flock for atomic locking (append mode to avoid truncating before lock acquired)
<     exec 9>>"$LOCK_FILE"
<     if ! flock -n 9; then
<       LOCK_PID=$(cat "$LOCK_FILE" 2>/dev/null || echo "unknown")
<       echo "ERROR: Ralph loop already running (lock: $LOCK_FILE, PID: $LOCK_PID)"
<       exit 1
<     fi
<     # Now holding lock, safe to overwrite with our PID
<     echo "$$" >"$LOCK_FILE"
<   else
<     # Portable fallback: noclobber atomic create
<     if ! ( set -o noclobber; echo "$$" > "$LOCK_FILE" ) 2>/dev/null; then
<       LOCK_PID=$(cat "$LOCK_FILE" 2>/dev/null || echo "unknown")
<       # Double-check: maybe we lost a race but the winner is now dead
<       if ! is_pid_running "$LOCK_PID"; then
<         echo "ðŸ§¹ Removing stale lock (PID $LOCK_PID no longer running)"
<         rm -f "$LOCK_FILE"
<         # Retry once
<         if ! ( set -o noclobber; echo "$$" > "$LOCK_FILE" ) 2>/dev/null; then
<           echo "ERROR: Ralph loop already running (lock: $LOCK_FILE)"
<           exit 1
<         fi
<       else
<         echo "ERROR: Ralph loop already running (lock: $LOCK_FILE, PID: $LOCK_PID)"
<         exit 1
<       fi
<     fi
<   fi
< }
< acquire_lock
<
< # Interrupt handling: First Ctrl+C = graceful exit, Second Ctrl+C = immediate exit
< INTERRUPT_COUNT=0
< INTERRUPT_RECEIVED=false
<
< # Cleanup function for temp files and lock
< cleanup() {
<   rm -f "$LOCK_FILE"
<   if [[ -n "${TEMP_CONFIG:-}" && -f "${TEMP_CONFIG:-}" ]]; then
<     rm -f "$TEMP_CONFIG"
<   fi
< }
<
< handle_interrupt() {
<   INTERRUPT_COUNT=$((INTERRUPT_COUNT + 1))
<
<   if [[ $INTERRUPT_COUNT -eq 1 ]]; then
<     echo ""
<     echo "========================================"
<     echo "âš ï¸  Interrupt received!"
<     echo "Will exit after current iteration completes."
<     echo "Press Ctrl+C again to force immediate exit."
<     echo "========================================"
<     INTERRUPT_RECEIVED=true
<   else
<     echo ""
<     echo "========================================"
<     echo "ðŸ›‘ Force exit!"
<     echo "========================================"
<     cleanup
<     kill 0
<     exit 130
<   fi
< }
<
< trap 'handle_interrupt' INT TERM
< trap 'cleanup' EXIT
<
< # Safe branch handling - ensures target branch exists without resetting history
< # Accepts optional branch name; defaults to WORK_BRANCH
< ensure_worktree_branch() {
<   local branch="${1:-$WORK_BRANCH}"
<   if git show-ref --verify --quiet "refs/heads/$branch"; then
<     git checkout "$branch"
<   else
<     echo "Creating new worktree branch: $branch"
<     git checkout -b "$branch"
<   fi
<
<   # Set upstream if not already set
<   if ! git rev-parse --abbrev-ref --symbolic-full-name "@{u}" >/dev/null 2>&1; then
<     echo "Setting upstream for $branch"
<     git push -u origin "$branch" 2>/dev/null || true
<   fi
< }
<
< usage() {
<   cat <<'EOF'
< Usage:
<   loop.sh [--prompt <path>] [--iterations N] [--plan-every N] [--yolo|--no-yolo]
<           [--runner rovodev|opencode] [--model <model>] [--branch <name>] [--dry-run] [--no-monitors]
<           [--opencode-serve] [--opencode-port N] [--opencode-attach <url>] [--opencode-format json|text]
<           [--rollback [N]] [--resume]
<
< Defaults:
<   --iterations 1
<   --plan-every 3
<   --runner      rovodev
<   --model       Sonnet 4.5 (rovodev) or Grok Code (opencode). Use --model auto for rovodev config.
<   --branch      Defaults to <repo>-work (e.g., brain-work, NeoQueue-work)
<   If --prompt is NOT provided, loop alternates:
<     - PLAN on iteration 1 and every N iterations
<     - BUILD otherwise
<   If --prompt IS provided, that prompt is used for all iterations.
<
< Model Selection:
<   --model <model>  Specify the model to use. Shortcuts available:
<                    sonnet  -> Sonnet 4.5 (anthropic.claude-sonnet-4-5-20250929-v1:0)
<                    opus    -> Opus 4.5 (anthropic.claude-opus-4-5-20251101-v1:0)
<                    sonnet4 -> Sonnet 4 (anthropic.claude-sonnet-4-20250514-v1:0)
<                     auto    -> Use default from ~/.rovodev/config.yml
<                     Or provide a full model ID directly.
<
< Runner Selection:
<   --runner rovodev|opencode
<                    rovodev: uses acli rovodev run (default)
<                    opencode: uses opencode run (provider/model). See: opencode models
<
< Branch Workflow:
<   --branch <name>  Work on specified branch (creates if needed, switches to it)
<                    Default: <repo>-work (derived from git remote, e.g., brain-work)
<                    Then run pr-batch.sh to create PRs to main
<
< Safety Features:
<   --dry-run       Preview changes without committing (appends instruction to prompt)
<   --no-monitors   Skip auto-launching monitor terminals (useful for CI/CD or headless environments)
<   --rollback [N]  Undo last N Ralph commits (default: 1). Requires confirmation.
<   --resume        Resume from last incomplete iteration (checks for uncommitted changes)
<
< OpenCode Options:
<   --opencode-serve      Start local OpenCode server for faster runs (implies --opencode-attach localhost:4096)
<   --opencode-port N     Port for OpenCode server (default: 4096)
<   --opencode-attach <url> Attach to running OpenCode server at <url> (e.g., http://localhost:4096)
<   --opencode-format default|json  Format for OpenCode output (default: default; use default for grep-based verifiers)
<
< Examples:
<   # Run BUILD once (from anywhere)
<   bash ralph/loop.sh --prompt ralph/PROMPT_build.md --iterations 1 --plan-every 999
<
<   # From inside ralph/
<   bash ./loop.sh --prompt ./PROMPT_build.md --iterations 1 --plan-every 999
<
<   # Alternate plan/build for 10 iters, plan every 3
<   bash ralph/loop.sh --iterations 10 --plan-every 3
<
<   # Use Sonnet model for faster iterations
<   bash ralph/loop.sh --model sonnet --iterations 20 --plan-every 5
<
<   # Use Opus for careful planning
<   bash ralph/loop.sh --model opus --iterations 1
<
<   # Dry-run mode (see what would change)
<   bash ralph/loop.sh --dry-run --iterations 1
<
<   # Run without monitor terminals (useful for CI/CD)
<   bash ralph/loop.sh --no-monitors --iterations 5
<
<   # Rollback last 2 iterations
<   bash ralph/loop.sh --rollback 2
<
<   # Resume after error
<   bash ralph/loop.sh --resume
< EOF
< }
<
< # Defaults
< ITERATIONS=1
< PLAN_EVERY=3
< YOLO_FLAG="--yolo"
< RUNNER="rovodev"
< PROMPT_ARG=""
< BRANCH_ARG=""
< DRY_RUN=false
< OPENCODE_SERVE=false
< OPENCODE_PORT=4096
< OPENCODE_ATTACH=""
< OPENCODE_FORMAT="default"
< ROLLBACK_MODE=false
< ROLLBACK_COUNT=1
< RESUME_MODE=false
< NO_MONITORS=false
<
< # Parse args
< while [[ $# -gt 0 ]]; do
<   case "$1" in
<     --prompt)
<       PROMPT_ARG="${2:-}"; shift 2 ;;
<     --iterations)
<       ITERATIONS="${2:-}"; shift 2 ;;
<     --plan-every)
<       PLAN_EVERY="${2:-}"; shift 2 ;;
<     --yolo)
<       YOLO_FLAG="--yolo"; shift ;;
<     --no-yolo)
<       YOLO_FLAG=""; shift ;;
<     --runner)
<       RUNNER="${2:-}"; shift 2 ;;
<     --opencode-serve)
<       OPENCODE_SERVE=true; shift ;;
<     --opencode-port)
<       OPENCODE_PORT="${2:-4096}"; shift 2 ;;
<     --opencode-attach)
<       OPENCODE_ATTACH="${2:-}"; shift 2 ;;
<     --opencode-format)
<       OPENCODE_FORMAT="${2:-default}"; shift 2 ;;
<     --model)
<     --branch)
<       BRANCH_ARG="${2:-}"; shift 2 ;;
<     --dry-run)
<       DRY_RUN=true; shift ;;
<     --no-monitors)
<       NO_MONITORS=true; shift ;;
<     --rollback)
<       ROLLBACK_MODE=true
<       if [[ -n "${2:-}" && "$2" =~ ^[0-9]+$ ]]; then
<         ROLLBACK_COUNT="$2"; shift 2
<       else
<         shift
<       fi ;;
<     --resume)
<       RESUME_MODE=true; shift ;;
<     -h|--help)
<       usage; exit 0 ;;
<     *)
<       echo "Unknown arg: $1" >&2
<       usage; exit 2 ;;
<   esac
< done
<
< # Model version configuration - SINGLE SOURCE OF TRUTH
< # Update these when new model versions are released
< # Last updated: 2026-01-18 (Sonnet 4.5 September 2025 release)
<
< # Resolve model shortcut to full model ID
< resolve_model() {
<   local model="$1"
<   case "$model" in
<     opus|opus4.5|opus45)
<     sonnet|sonnet4.5|sonnet45)
<     sonnet4)
<     latest|auto)
<       # Use system default - don't override config
<       echo "" ;;
<     *)
<       echo "$model" ;;
<   esac
< }
<
< # Resolve model shortcut to OpenCode provider/model.
< # IMPORTANT: Replace placeholder IDs below with the *exact* IDs from: opencode models
< resolve_model_opencode() {
<   local model="$1"
<   case "$model" in
<     grok|grokfast|grok-code-fast-1)
<       # Confirmed via opencode models
<       echo "opencode/grok-code" ;;
<     opus|opus4.5|opus45)
<       # Placeholder - anthropic not available in current setup
<       echo "opencode/gpt-5-nano" ;;  # Fallback to available model
<     sonnet|sonnet4.5|sonnet45)
<       # Placeholder - anthropic not available
<       echo "opencode/gpt-5-nano" ;;  # Fallback
<     latest|auto)
<       # Let OpenCode decide its own default if user explicitly asked for auto/latest
<       echo "" ;;
<     *)
<       # Pass through (user provided provider/model already, or an OpenCode alias)
<       echo "$model" ;;
<   esac
< }
<
< # Setup model config - default to Sonnet 4.5 for Ralph loops
< CONFIG_FLAG=""
< TEMP_CONFIG=""
<
< # Use provided model or default based on runner
<   if [[ "$RUNNER" == "opencode" ]]; then
<   else
<   fi
< fi
<
< if [[ "$RUNNER" == "opencode" ]]; then
< else
< fi
<
< # Only create RovoDev temp config when runner=rovodev and we have a model to set
< if [[ "$RUNNER" == "rovodev" ]]; then
<   if [[ -n "$RESOLVED_MODEL" ]]; then
<     TEMP_CONFIG="/tmp/rovodev_config_$$_$(date +%s).yml"
<
<     # Copy base config and override modelId
<     if [[ -f "$HOME/.rovodev/config.yml" ]]; then
<       sed "s|^  modelId:.*|  modelId: $RESOLVED_MODEL|" "$HOME/.rovodev/config.yml" > "$TEMP_CONFIG"
<     else
<       cat > "$TEMP_CONFIG" <<EOFCONFIG
< version: 1
< agent:
<   modelId: $RESOLVED_MODEL
< EOFCONFIG
<     fi
<     CONFIG_FLAG="--config-file $TEMP_CONFIG"
<     echo "Using model: $RESOLVED_MODEL"
<   fi
< else
<   # OpenCode runner uses provider/model directly; no temp config needed.
<   if [[ -n "$RESOLVED_MODEL" ]]; then
<     echo "Using model: $RESOLVED_MODEL"
<   else
<     echo "Using model: (OpenCode default)"
<   fi
< fi
<
< # Resolve target branch:
< # 1. User-provided --branch takes precedence
< # 2. On --resume without --branch, stay on current branch
< # 3. Otherwise use default WORK_BRANCH
< if [[ -n "$BRANCH_ARG" ]]; then
<   TARGET_BRANCH="$BRANCH_ARG"
< elif [[ "$RESUME_MODE" == "true" ]]; then
<   TARGET_BRANCH="$(git -C "$ROOT" rev-parse --abbrev-ref HEAD 2>/dev/null || echo "$WORK_BRANCH")"
< else
<   TARGET_BRANCH="$WORK_BRANCH"
< fi
<
< # Debug output for derived values
< echo "Repo: $REPO_NAME | Branch: $TARGET_BRANCH | Lock: $LOCK_FILE"
<
< # Resolve a prompt path robustly (works from repo root or ralph/)
< resolve_prompt() {
<   local p="$1"
<   if [[ -z "$p" ]]; then return 1; fi
<
<   # 1) As provided (relative to current working directory)
<   if [[ -f "$p" ]]; then
<     realpath "$p"
<     return 0
<   fi
<
<   # 2) Relative to repo root
<   if [[ -f "$ROOT/$p" ]]; then
<     realpath "$ROOT/$p"
<     return 0
<   fi
<
<   echo "Prompt not found: $p (checked: '$p' and '$ROOT/$p')" >&2
<   return 1
< }
<
< # Handle rollback mode
< if [[ "$ROLLBACK_MODE" == "true" ]]; then
<   echo "========================================"
<   echo "ðŸ”„ Rollback Mode"
<   echo "========================================"
<   echo ""
<
<   # Show last N commits
<   echo "Last $ROLLBACK_COUNT commit(s) to be reverted:"
<   echo ""
<   git log --oneline -n "$ROLLBACK_COUNT"
<   echo ""
<
<   # Confirmation
<   read -p "âš ï¸  Revert these $ROLLBACK_COUNT commit(s)? (type 'yes' to confirm): " confirm
<   if [[ "$confirm" != "yes" ]]; then
<     echo "Rollback cancelled."
<     exit 0
<   fi
<
<   # Perform rollback
<   echo ""
<   echo "Reverting last $ROLLBACK_COUNT commit(s)..."
<   if git reset --hard HEAD~"$ROLLBACK_COUNT"; then
<     echo "âœ… Rollback successful!"
<     echo ""
<     echo "Current HEAD:"
<     git log --oneline -n 1
<   else
<     echo "âŒ Rollback failed!"
<     exit 1
<   fi
<
<   exit 0
< fi
<
< # Handle resume mode
< if [[ "$RESUME_MODE" == "true" ]]; then
<   echo "========================================"
<   echo "ðŸ”„ Resume Mode"
<   echo "========================================"
<   echo ""
<
<   # Check for uncommitted changes
<   if git diff --quiet && git diff --cached --quiet; then
<     echo "No uncommitted changes found."
<     echo "Nothing to resume. Repository is clean."
<     exit 0
<   fi
<
<   echo "Uncommitted changes detected:"
<   echo ""
<   git status --short
<   echo ""
<
<   read -p "Continue from this state? (yes/no): " confirm
<   if [[ "$confirm" != "yes" ]]; then
<     echo "Resume cancelled."
<     exit 0
<   fi
<
<   echo "âœ… Continuing with existing changes..."
<   echo ""
< fi
<
< # Handle branch switching
< if [[ -n "$BRANCH_ARG" ]]; then
<   CURRENT_BRANCH=$(git branch --show-current)
<   if [[ "$CURRENT_BRANCH" != "$BRANCH_ARG" ]]; then
<     echo "========================================"
<     echo "ðŸŒ¿ Branch: $BRANCH_ARG"
<     echo "========================================"
<
<     # Check if branch exists
<     if git show-ref --verify --quiet "refs/heads/$BRANCH_ARG"; then
<       git checkout "$BRANCH_ARG"
<     else
<       echo "Creating new branch: $BRANCH_ARG"
<       git checkout -b "$BRANCH_ARG"
<       # Push if remote exists
<       if git remote get-url origin &>/dev/null; then
<         git push -u origin "$BRANCH_ARG" 2>/dev/null || true
<       fi
<     fi
<     echo ""
<   fi
< fi
<
< # Ralph determines mode from iteration number (PROMPT.md has conditional logic)
< PLAN_PROMPT="$RALPH/PROMPT.md"
< BUILD_PROMPT="$RALPH/PROMPT.md"
<
< # Verifier gate - runs rules/AC.rules checks after BUILD
< VERIFY_SCRIPT="$RALPH/verifier.sh"
< RUN_ID_FILE="$RALPH/.verify/run_id.txt"
< INIT_SCRIPT="$RALPH/init_verifier_baselines.sh"
<
< # Auto-init verifier baselines if missing
< init_verifier_if_needed() {
<   if [[ -x "$INIT_SCRIPT" && ! -f "$AC_HASH_FILE" ]]; then
<     echo ""
<     echo "========================================"
<     echo "ðŸ”§ Initializing verifier baselines..."
<     echo "========================================"
<     if "$INIT_SCRIPT"; then
<       echo "âœ… Baselines initialized successfully"
<     else
<       echo "âŒ Failed to initialize baselines"
<       return 1
<     fi
<   fi
<   return 0
< }
<
< # Track last verifier result for prompt injection
< LAST_VERIFIER_STATUS=""
< LAST_VERIFIER_FAILED_RULES=""
< LAST_VERIFIER_FAIL_COUNT=0
<
< # Parse verifier report to extract failed rules
< parse_verifier_failures() {
<   local report_file="$1"
<   [[ -f "$report_file" ]] || return
<
<   local rules=""
<   local count=0
<
<   # Extract [FAIL] rule IDs (standard format)
<   local standard_fails
<   standard_fails=$(grep -oE '^\[FAIL\] [A-Za-z0-9_.]+' "$report_file" 2>/dev/null | sed 's/\[FAIL\] //' | tr '\n' ',' | sed 's/,$//' | sed 's/,,*/,/g')
<   local standard_count
<   standard_count=$(grep -c '^\[FAIL\]' "$report_file" 2>/dev/null || echo "0")
<
<   # Check for hash guard failure (special format: [timestamp] FAIL: AC hash mismatch)
<   if grep -q 'FAIL: AC hash mismatch' "$report_file" 2>/dev/null; then
<     rules="HashGuard"
<     count=1
<   fi
<
<   # Combine results
<   if [[ -n "$standard_fails" ]]; then
<     if [[ -n "$rules" ]]; then
<       rules="$rules, $standard_fails"
<     else
<       rules="$standard_fails"
<     fi
<     count=$((count + standard_count))
<   fi
<
<   LAST_VERIFIER_FAILED_RULES="$rules"
<   LAST_VERIFIER_FAIL_COUNT="$count"
< }
<
< # Check if Ralph requested human intervention in the log
< check_human_intervention() {
<   local log_file="$1"
<   # Strip ANSI codes and check for human intervention marker
<   if sed 's/\x1b\[[0-9;]*m//g' "$log_file" | grep -q 'HUMAN INTERVENTION REQUIRED'; then
<     return 0  # intervention needed
<   fi
<   return 1  # no intervention needed
< }
<
< # Check if previous verifier found protected file failures (requires human intervention)
< check_protected_file_failures() {
<   # If no failed rules, nothing to check
<   [[ -z "$LAST_VERIFIER_FAILED_RULES" ]] && return 1
<
<   # Check if any Protected.* rules failed
<   if echo "$LAST_VERIFIER_FAILED_RULES" | grep -qE 'Protected\.[0-9]+'; then
<     return 0  # protected file failures found
<   fi
<   return 1  # no protected file failures
< }
<
< run_verifier() {
<   if [[ ! -x "$VERIFY_SCRIPT" ]]; then
<     echo "âš ï¸  Verifier not found or not executable: $VERIFY_SCRIPT"
<     LAST_VERIFIER_STATUS="SKIP"
<     return 0  # Don't block if verifier doesn't exist yet
<   fi
<
<   # Auto-init baselines if missing
<   if ! init_verifier_if_needed; then
<     LAST_VERIFIER_STATUS="FAIL"
<     LAST_VERIFIER_FAILED_RULES="init_baselines"
<     LAST_VERIFIER_FAIL_COUNT=1
<     return 1
<   fi
<
<   echo ""
<   echo "========================================"
<   echo "ðŸ” Running acceptance criteria verifier..."
<   echo "========================================"
<
<   # Generate unique run ID for freshness check
<   RUN_ID="$(date +%s)-$$"
<   export RUN_ID
<
<   if "$VERIFY_SCRIPT"; then
<     # Verify freshness: run_id.txt must match our RUN_ID
<     if [[ -f "$RUN_ID_FILE" ]]; then
<       local stored_id
<       stored_id=$(cat "$RUN_ID_FILE" 2>/dev/null)
<       if [[ "$stored_id" != "$RUN_ID" ]]; then
<         echo "âŒ Freshness check FAILED: run_id mismatch"
<         echo "   Expected: $RUN_ID"
<         echo "   Got: $stored_id"
<         LAST_VERIFIER_STATUS="FAIL"
<         LAST_VERIFIER_FAILED_RULES="freshness_check"
<         LAST_VERIFIER_FAIL_COUNT=1
<         return 1
<       fi
<     else
<       echo "âŒ Freshness check FAILED: run_id.txt not found"
<       LAST_VERIFIER_STATUS="FAIL"
<       LAST_VERIFIER_FAILED_RULES="freshness_check"
<       LAST_VERIFIER_FAIL_COUNT=1
<       return 1
<     fi
<
<     echo "âœ… All acceptance criteria passed! (run_id: $RUN_ID)"
<     cat "$RALPH/.verify/latest.txt" 2>/dev/null | tail -10 || true
<     LAST_VERIFIER_STATUS="PASS"
<     LAST_VERIFIER_FAILED_RULES=""
<     LAST_VERIFIER_FAIL_COUNT=0
<     return 0
<   else
<     echo "âŒ Acceptance criteria FAILED"
<     echo ""
<     cat "$RALPH/.verify/latest.txt" 2>/dev/null || echo "(no report found)"
<     LAST_VERIFIER_STATUS="FAIL"
<     parse_verifier_failures "$RALPH/.verify/latest.txt"
<     return 1
<   fi
< }
<
< run_once() {
<   local prompt_file="$1"
<   local phase="$2"
<   local iter="$3"
<
<   local ts
<   ts="$(date +%F_%H%M%S)"
<   local log="$LOGDIR/${ts}_iter${iter}_${phase}.log"
<
<   echo
<   echo "========================================"
<   echo "Ralph Loop"
<   echo "Root: $ROOT"
<   echo "Iteration: $iter / $ITERATIONS"
<   echo "Phase: $phase"
<   echo "Prompt: $prompt_file"
<   echo "Log: $log"
<   echo "========================================"
<   echo
<
<   # Create temporary prompt with mode prepended
<   local prompt_with_mode="/tmp/rovodev_prompt_with_mode_$$_${iter}.md"
<   {
<     echo "# MODE: ${phase^^}"
<     echo ""
<
<     # Inject verifier status from previous iteration (if any)
<     if [[ -n "$LAST_VERIFIER_STATUS" ]]; then
<       echo "# LAST_VERIFIER_RESULT: $LAST_VERIFIER_STATUS"
<       if [[ "$LAST_VERIFIER_STATUS" == "FAIL" ]]; then
<         echo "# FAILED_RULES: $LAST_VERIFIER_FAILED_RULES"
<         echo "# FAILURE_COUNT: $LAST_VERIFIER_FAIL_COUNT"
<         echo "# ACTION_REQUIRED: Read .verify/latest.txt and fix AC failures BEFORE picking new tasks."
<       fi
<       echo ""
<     fi
<
<     cat "$prompt_file"
<
<     # Append dry-run instruction if enabled
<     if [[ "$DRY_RUN" == "true" ]]; then
<       echo ""
<       echo "---"
<       echo ""
<       echo "# DRY-RUN MODE ACTIVE"
<       echo ""
<       echo "âš ï¸ **CRITICAL: This is a dry-run. DO NOT commit any changes.**"
<       echo ""
<       echo "Your task:"
<       echo "1. Read IMPLEMENTATION_PLAN.md and identify the first unchecked task"
<       echo "2. Analyze what changes would be needed to implement it"
<       echo "3. Show file diffs or describe modifications you would make"
<       echo "4. Update IMPLEMENTATION_PLAN.md with detailed notes about your findings"
<       echo "5. DO NOT use git commit - stop after analysis"
<       echo ""
<       echo "Output format:"
<       echo "- List files that would be created/modified"
<       echo "- Show code snippets or diffs for key changes"
<       echo "- Document any risks or dependencies discovered"
<       echo "- Add findings to IMPLEMENTATION_PLAN.md under 'Discoveries & Notes'"
<       echo ""
<       echo "This is a preview only. No commits will be made."
<     fi
<   } > "$prompt_with_mode"
<
<   # Feed prompt into selected runner
<   if [[ "$RUNNER" == "opencode" ]]; then
<     # NOTE: Passing full prompt as CLI arg can hit shell/argv limits if prompt is huge.
<     # If that happens, pivot to a file-based approach after validating basic integration.
<     attach_flag=""
<     if [[ -n "${OPENCODE_ATTACH:-}" ]]; then
<       attach_flag="--attach ${OPENCODE_ATTACH}"
<     fi
<     opencode run ${attach_flag} --model "${RESOLVED_MODEL}" --format "${OPENCODE_FORMAT}" "$(cat "$prompt_with_mode")" 2>&1 | tee "$log"
<     rc=$?
<     if [[ $rc -ne 0 ]]; then
<       echo "âŒ OpenCode failed (exit $rc). See: $log"
<       tail -n 80 "$log" || true
<       return 1
<     fi
<   else
<     # Default: RovoDev
<     script -q -c "cat \"$prompt_with_mode\" | acli rovodev run ${CONFIG_FLAG} ${YOLO_FLAG}" "$log"
<   fi
<
<   # Clean up temporary prompt
<   rm -f "$prompt_with_mode"
<
<   echo
<   echo "Run complete."
<   echo "Transcript: $log"
<
<   # In dry-run mode, remind user no commits were made
<   if [[ "$DRY_RUN" == "true" ]]; then
<     echo ""
<     echo "========================================"
<     echo "ðŸ” Dry-run completed"
<     echo "No changes were committed."
<     echo "Review the transcript above for analysis."
<     echo "========================================"
<   fi
<
<
<   # Run verifier after both PLAN and BUILD iterations
<   if [[ "$phase" == "plan" ]] || [[ "$phase" == "build" ]]; then
<     if run_verifier; then
<       echo ""
<       echo "========================================"
<       echo "ðŸŽ‰ ${phase^^} iteration verified successfully!"
<       echo "========================================"
<     else
<       echo ""
<       echo "========================================"
<       echo "âš ï¸  ${phase^^} completed but verification failed."
<       echo "Review .verify/latest.txt for details."
<       echo "========================================"
<     fi
<   fi
<
<   # Legacy: also check for :::COMPLETE::: but ignore it (loop.sh owns completion now)
<   if sed 's/\x1b\[[0-9;]*m//g' "$log" | grep -qE '^\s*:::COMPLETE:::\s*$'; then
<     echo ""
<     echo "âš ï¸  Ralph output :::COMPLETE::: but that token is reserved for loop.sh."
<     echo "Ignoring - use :::BUILD_READY::: or :::PLAN_READY::: instead."
<   fi
<
<   # Check if Ralph requested human intervention
<   if check_human_intervention "$log"; then
<     echo ""
<     echo "========================================"
<     echo "ðŸ›‘ HUMAN INTERVENTION REQUIRED"
<     echo "========================================"
<     echo "Ralph has indicated it cannot proceed without human help."
<     echo "Review the log above for details."
<     echo ""
<     return 43  # Special return code for human intervention
<   fi
<
<   # Check if all tasks are done (for true completion)
<   if [[ -f "$RALPH/IMPLEMENTATION_PLAN.md" ]]; then
<     local unchecked_count
<     # Note: grep -c returns exit 1 when count is 0, so we capture output first then default
<     unchecked_count=$(grep -cE '^\s*-\s*\[ \]' "$RALPH/IMPLEMENTATION_PLAN.md" 2>/dev/null) || unchecked_count=0
<     if [[ "$unchecked_count" -eq 0 ]]; then
<       # All tasks done - run final verification
<       if run_verifier; then
<         echo ""
<         echo "========================================"
<         echo "ðŸŽ‰ All tasks complete and verified!"
<         echo "========================================"
<         return 42  # Special return code for completion
<       fi
<     fi
<   fi
<
<   return 0
< }
<
< # Launch a script in a new terminal window
< # Args: $1 = window title, $2 = script path, $3 = process grep pattern
< # Returns: 0 if launched successfully, 1 otherwise
< launch_in_terminal() {
<   local title="$1"
<   local script_path="$2"
<   local process_pattern="$3"
<
<   # Try to detect available terminal emulator (priority order: tmux, wt.exe, gnome-terminal, konsole, xterm)
<   # All terminal launches redirect stderr to /dev/null to suppress dbus/X11 errors
<   if [[ -n "${TMUX:-}" ]]; then
<     if tmux new-window -n "$title" "bash $script_path" 2>/dev/null; then
<       return 0
<     fi
<   elif command -v wt.exe &>/dev/null; then
<     wt.exe new-tab --title "$title" -- wsl bash "$script_path" 2>/dev/null &
<     sleep 0.5
<     if pgrep -f "$process_pattern" > /dev/null; then
<       return 0
<     fi
<   elif command -v gnome-terminal &>/dev/null; then
<     gnome-terminal --title="$title" -- bash "$script_path" 2>/dev/null &
<     sleep 0.5  # Give it time to fail
<     if pgrep -f "$process_pattern" > /dev/null; then
<       return 0
<     fi
<   elif command -v konsole &>/dev/null; then
<     konsole --title "$title" -e bash "$script_path" 2>/dev/null &
<     sleep 0.5
<     if pgrep -f "$process_pattern" > /dev/null; then
<       return 0
<     fi
<   elif command -v xterm &>/dev/null; then
<     xterm -T "$title" -e bash "$script_path" 2>/dev/null &
<     sleep 0.5
<     if pgrep -f "$process_pattern" > /dev/null; then
<       return 0
<     fi
<   fi
<
<   return 1
< }
<
< # Auto-launch monitors in background if not already running
< launch_monitors() {
<   local monitor_dir="$RALPH"
<   local current_tasks_launched=false
<   local thunk_tasks_launched=false
<
<   # Check if current_ralph_tasks.sh exists and launch
<   if [[ -f "$monitor_dir/current_ralph_tasks.sh" ]]; then
<     if ! pgrep -f "current_ralph_tasks.sh" > /dev/null; then
<       if launch_in_terminal "Current Tasks" "$monitor_dir/current_ralph_tasks.sh" "current_ralph_tasks.sh"; then
<         current_tasks_launched=true
<       fi
<     else
<       current_tasks_launched=true  # Already running
<     fi
<   fi
<
<   # Check if thunk_ralph_tasks.sh exists and launch
<   if [[ -f "$monitor_dir/thunk_ralph_tasks.sh" ]]; then
<     if ! pgrep -f "thunk_ralph_tasks.sh" > /dev/null; then
<       if launch_in_terminal "Thunk Tasks" "$monitor_dir/thunk_ralph_tasks.sh" "thunk_ralph_tasks.sh"; then
<         thunk_tasks_launched=true
<       fi
<     else
<       thunk_tasks_launched=true  # Already running
<     fi
<   fi
<
<   # If both monitors failed to launch, print consolidated fallback message
<   if [[ "$current_tasks_launched" == "false" && "$thunk_tasks_launched" == "false" ]]; then
<     echo ""
<     echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
<     echo "  âš ï¸  Could not auto-launch monitor terminals."
<     echo ""
<     echo "  To run monitors manually, open new terminals and run:"
<     echo "    bash $monitor_dir/current_ralph_tasks.sh"
<     echo "    bash $monitor_dir/thunk_ralph_tasks.sh"
<     echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
<     echo ""
<    fi
< }
<
< # Start OpenCode server if requested
< if [[ "$RUNNER" == "opencode" ]]; then
<   if $OPENCODE_SERVE; then
<     OPENCODE_ATTACH="http://localhost:${OPENCODE_PORT}"
<     opencode serve --port "$OPENCODE_PORT" >/tmp/opencode_serve.log 2>&1 &
<     OPENCODE_SERVE_PID=$!
<     trap '[[ -n "${OPENCODE_SERVE_PID:-}" ]] && kill "$OPENCODE_SERVE_PID" 2>/dev/null' EXIT
<   fi
< fi
<
< # Fail fast if opencode runner but command not found
< if [[ "$RUNNER" == "opencode" ]]; then
<   command -v opencode >/dev/null 2>&1 || { echo "ERROR: opencode not found in PATH"; exit 1; }
< fi
<
< # Health check for attach endpoint (TCP port check)
< if [[ -n "${OPENCODE_ATTACH:-}" ]]; then
<   hostport="${OPENCODE_ATTACH#http://}"
<   hostport="${hostport#https://}"
<   hostport="${hostport%%/*}"
<   h="${hostport%%:*}"
<   p="${hostport##*:}"
<   if ! (echo > /dev/tcp/"$h"/"$p") >/dev/null 2>&1; then
<     echo "WARN: OpenCode attach endpoint not reachable; running without --attach"
<     OPENCODE_ATTACH=""
<   fi
< fi
<
< # Print effective config for debugging
< echo "Runner=${RUNNER} Model=${RESOLVED_MODEL:-<default>} Format=${OPENCODE_FORMAT:-<default>} Attach=${OPENCODE_ATTACH:-<none>} Serve=${OPENCODE_SERVE:-false}"
<
< # Ensure we're on the worktree branch before starting
< echo ""
< echo "========================================"
< echo "Setting up worktree branch: $TARGET_BRANCH"
< echo "========================================"
< ensure_worktree_branch "$TARGET_BRANCH"
< echo ""
<
< # Launch monitors before starting iterations (unless --no-monitors flag is set)
< if [[ "$NO_MONITORS" == "false" ]]; then
<   launch_monitors
< fi
<
< # Determine prompt strategy
< if [[ -n "$PROMPT_ARG" ]]; then
<   PROMPT_FILE="$(resolve_prompt "$PROMPT_ARG")"
<   for ((i=1; i<=ITERATIONS; i++)); do
<     # Check for interrupt before starting iteration
<     if [[ "$INTERRUPT_RECEIVED" == "true" ]]; then
<       echo ""
<       echo "Exiting gracefully after iteration $((i-1))."
<       exit 130
<     fi
<
<     # Check for protected file failures before starting LLM (requires human intervention)
<     if check_protected_file_failures; then
<       echo ""
<       echo "========================================"
<       echo "ðŸ›‘ HUMAN INTERVENTION REQUIRED"
<       echo "========================================"
<       echo "Protected file hash mismatches detected: $LAST_VERIFIER_FAILED_RULES"
<       echo ""
<       echo "These files are protected and cannot be fixed by Ralph."
<       echo ""
<       # Show which specific files failed
<       if [[ -f "$VERIFY_REPORT" ]]; then
<         echo "Failed protected files:"
<         grep "^\[FAIL\] Protected\." "$VERIFY_REPORT" | while read -r line; do
<           if echo "$line" | grep -q "Protected.1"; then
<             echo "  - loop.sh"
<           elif echo "$line" | grep -q "Protected.2"; then
<             echo "  - verifier.sh"
<           elif echo "$line" | grep -q "Protected.3"; then
<             echo "  - PROMPT.md"
<           elif echo "$line" | grep -q "Protected.4"; then
<             echo "  - rules/AC.rules"
<           fi
<         done
<         echo ""
<       fi
<       echo "To regenerate baselines for these files:"
<       echo "  cd brain/ralph"
<       echo ""
<       echo "After resolving, re-run the loop to continue."
<       exit 1
<     fi
<
<     # Capture exit code without triggering set -e
<     run_result=0
<     run_once "$PROMPT_FILE" "custom" "$i" || run_result=$?
<     # Check if Ralph signaled completion
<     if [[ $run_result -eq 42 ]]; then
<       echo ""
<       echo "Loop terminated early due to completion."
<       break
<     fi
<     # Check if Ralph requested human intervention
<     if [[ $run_result -eq 43 ]]; then
<       echo ""
<       echo "Loop paused - human intervention required."
<       echo "After resolving the issue, re-run the loop to continue."
<       exit 1
<     fi
<   done
< else
<   # Alternating plan/build
<   for ((i=1; i<=ITERATIONS; i++)); do
<     # Check for interrupt before starting iteration
<     if [[ "$INTERRUPT_RECEIVED" == "true" ]]; then
<       echo ""
<       echo "Exiting gracefully after iteration $((i-1))."
<       exit 130
<     fi
<
<     # Check for protected file failures before starting LLM (requires human intervention)
<     if check_protected_file_failures; then
<       echo ""
<       echo "========================================"
<       echo "ðŸ›‘ HUMAN INTERVENTION REQUIRED"
<       echo "========================================"
<       echo "Protected file hash mismatches detected: $LAST_VERIFIER_FAILED_RULES"
<       echo ""
<       echo "These files are protected and cannot be fixed by Ralph."
<       echo ""
<       # Show which specific files failed
<       if [[ -f "$VERIFY_REPORT" ]]; then
<         echo "Failed protected files:"
<         grep "^\[FAIL\] Protected\." "$VERIFY_REPORT" | while read -r line; do
<           if echo "$line" | grep -q "Protected.1"; then
<             echo "  - loop.sh"
<           elif echo "$line" | grep -q "Protected.2"; then
<             echo "  - verifier.sh"
<           elif echo "$line" | grep -q "Protected.3"; then
<             echo "  - PROMPT.md"
<           elif echo "$line" | grep -q "Protected.4"; then
<             echo "  - rules/AC.rules"
<           fi
<         done
<         echo ""
<       fi
<       echo "To regenerate baselines for these files:"
<       echo "  cd brain/ralph"
<       echo ""
<       echo "After resolving, re-run the loop to continue."
<       exit 1
<     fi
<
<     # Capture exit code without triggering set -e
<     run_result=0
<     if [[ "$i" -eq 1 ]] || (( PLAN_EVERY > 0 && ( (i-1) % PLAN_EVERY == 0 ) )); then
<       run_once "$PLAN_PROMPT" "plan" "$i" || run_result=$?
<     else
<       run_once "$BUILD_PROMPT" "build" "$i" || run_result=$?
<     fi
<     # Check if Ralph signaled completion (exit code 42)
<     if [[ $run_result -eq 42 ]]; then
<       echo ""
<       echo "Loop terminated early due to completion."
<       break
<     fi
<     # Check if Ralph requested human intervention (exit code 43)
<     if [[ $run_result -eq 43 ]]; then
<       echo ""
<       echo "Loop paused - human intervention required."
<       echo "After resolving the issue, re-run the loop to continue."
<       exit 1
<     fi
<   done
< fi
differ
  reasons:
    - stdout mismatch expected='match' got='1,1054d0
< #!/usr/bin/env bash
< set -euo pipefail
<
< # ROOT can be overridden via env var for project delegation
< if [[ -n "${RALPH_PROJECT_ROOT:-}" ]]; then
<   ROOT="$RALPH_PROJECT_ROOT"
<   RALPH="$ROOT/workers/ralph"
< else
<   ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")/../.." && pwd)"
<   RALPH="$ROOT/workers/ralph"
< fi
< LOGDIR="$RALPH/logs"
< mkdir -p "$LOGDIR"
<
< # Configurable Brain repo for commit trailers
< BRAIN_REPO="${BRAIN_REPO:-jonathanavis96/brain}"
<
< # Derive clean branch name from git repo name
< # Derive repo name from git remote (stable across machines) or fall back to folder name
< # Use git -C "$ROOT" to ensure commands run against the intended project directory
< if git -C "$ROOT" remote get-url origin &>/dev/null; then
<   REPO_NAME=$(basename -s .git "$(git -C "$ROOT" remote get-url origin)")
< else
<   REPO_NAME=$(basename "$ROOT")
< fi
< WORK_BRANCH="${REPO_NAME}-work"
<
< # Lock file to prevent concurrent runs
< # Lock file includes hash of repo path for uniqueness across same-named repos
< REPO_PATH_HASH=$(cd "$ROOT" && pwd | md5sum | cut -c1-8)
< LOCK_FILE="/tmp/ralph-${REPO_NAME}-${REPO_PATH_HASH}.lock"
<
< # TARGET_BRANCH will be set after arg parsing (uses BRANCH_ARG if provided, else WORK_BRANCH)
<
< # Check if a PID is still running
< is_pid_running() {
<   local pid="$1"
<   if [[ -z "$pid" || "$pid" == "unknown" ]]; then
<     return 1  # Invalid PID, treat as not running
<   fi
<   # Check if process exists (works on Linux/macOS)
<   kill -0 "$pid" 2>/dev/null
< }
<
< # Atomic lock acquisition with stale lock detection
< acquire_lock() {
<   # First, check for stale lock
<   if [[ -f "$LOCK_FILE" ]]; then
<     LOCK_PID=$(cat "$LOCK_FILE" 2>/dev/null || echo "unknown")
<     if ! is_pid_running "$LOCK_PID"; then
<       echo "ðŸ§¹ Removing stale lock (PID $LOCK_PID no longer running)"
<       rm -f "$LOCK_FILE"
<     fi
<   fi
<
<   if command -v flock &>/dev/null; then
<     # Use flock for atomic locking (append mode to avoid truncating before lock acquired)
<     exec 9>>"$LOCK_FILE"
<     if ! flock -n 9; then
<       LOCK_PID=$(cat "$LOCK_FILE" 2>/dev/null || echo "unknown")
<       echo "ERROR: Ralph loop already running (lock: $LOCK_FILE, PID: $LOCK_PID)"
<       exit 1
<     fi
<     # Now holding lock, safe to overwrite with our PID
<     echo "$$" >"$LOCK_FILE"
<   else
<     # Portable fallback: noclobber atomic create
<     if ! ( set -o noclobber; echo "$$" > "$LOCK_FILE" ) 2>/dev/null; then
<       LOCK_PID=$(cat "$LOCK_FILE" 2>/dev/null || echo "unknown")
<       # Double-check: maybe we lost a race but the winner is now dead
<       if ! is_pid_running "$LOCK_PID"; then
<         echo "ðŸ§¹ Removing stale lock (PID $LOCK_PID no longer running)"
<         rm -f "$LOCK_FILE"
<         # Retry once
<         if ! ( set -o noclobber; echo "$$" > "$LOCK_FILE" ) 2>/dev/null; then
<           echo "ERROR: Ralph loop already running (lock: $LOCK_FILE)"
<           exit 1
<         fi
<       else
<         echo "ERROR: Ralph loop already running (lock: $LOCK_FILE, PID: $LOCK_PID)"
<         exit 1
<       fi
<     fi
<   fi
< }
< acquire_lock
<
< # Interrupt handling: First Ctrl+C = graceful exit, Second Ctrl+C = immediate exit
< INTERRUPT_COUNT=0
< INTERRUPT_RECEIVED=false
<
< # Cleanup function for temp files and lock
< cleanup() {
<   rm -f "$LOCK_FILE"
<   if [[ -n "${TEMP_CONFIG:-}" && -f "${TEMP_CONFIG:-}" ]]; then
<     rm -f "$TEMP_CONFIG"
<   fi
< }
<
< handle_interrupt() {
<   INTERRUPT_COUNT=$((INTERRUPT_COUNT + 1))
<
<   if [[ $INTERRUPT_COUNT -eq 1 ]]; then
<     echo ""
<     echo "========================================"
<     echo "âš ï¸  Interrupt received!"
<     echo "Will exit after current iteration completes."
<     echo "Press Ctrl+C again to force immediate exit."
<     echo "========================================"
<     INTERRUPT_RECEIVED=true
<   else
<     echo ""
<     echo "========================================"
<     echo "ðŸ›‘ Force exit!"
<     echo "========================================"
<     cleanup
<     kill 0
<     exit 130
<   fi
< }
<
< trap 'handle_interrupt' INT TERM
< trap 'cleanup' EXIT
<
< # Safe branch handling - ensures target branch exists without resetting history
< # Accepts optional branch name; defaults to WORK_BRANCH
< ensure_worktree_branch() {
<   local branch="${1:-$WORK_BRANCH}"
<   if git show-ref --verify --quiet "refs/heads/$branch"; then
<     git checkout "$branch"
<   else
<     echo "Creating new worktree branch: $branch"
<     git checkout -b "$branch"
<   fi
<
<   # Set upstream if not already set
<   if ! git rev-parse --abbrev-ref --symbolic-full-name "@{u}" >/dev/null 2>&1; then
<     echo "Setting upstream for $branch"
<     git push -u origin "$branch" 2>/dev/null || true
<   fi
< }
<
< usage() {
<   cat <<'EOF'
< Usage:
<   loop.sh [--prompt <path>] [--iterations N] [--plan-every N] [--yolo|--no-yolo]
<           [--runner rovodev|opencode] [--model <model>] [--branch <name>] [--dry-run] [--no-monitors]
<           [--opencode-serve] [--opencode-port N] [--opencode-attach <url>] [--opencode-format json|text]
<           [--rollback [N]] [--resume]
<
< Defaults:
<   --iterations 1
<   --plan-every 3
<   --runner      rovodev
<   --model       Sonnet 4.5 (rovodev) or Grok Code (opencode). Use --model auto for rovodev config.
<   --branch      Defaults to <repo>-work (e.g., brain-work, NeoQueue-work)
<   If --prompt is NOT provided, loop alternates:
<     - PLAN on iteration 1 and every N iterations
<     - BUILD otherwise
<   If --prompt IS provided, that prompt is used for all iterations.
<
< Model Selection:
<   --model <model>  Specify the model to use. Shortcuts available:
<                    sonnet  -> Sonnet 4.5 (anthropic.claude-sonnet-4-5-20250929-v1:0)
<                    opus    -> Opus 4.5 (anthropic.claude-opus-4-5-20251101-v1:0)
<                    sonnet4 -> Sonnet 4 (anthropic.claude-sonnet-4-20250514-v1:0)
<                     auto    -> Use default from ~/.rovodev/config.yml
<                     Or provide a full model ID directly.
<
< Runner Selection:
<   --runner rovodev|opencode
<                    rovodev: uses acli rovodev run (default)
<                    opencode: uses opencode run (provider/model). See: opencode models
<
< Branch Workflow:
<   --branch <name>  Work on specified branch (creates if needed, switches to it)
<                    Default: <repo>-work (derived from git remote, e.g., brain-work)
<                    Then run pr-batch.sh to create PRs to main
<
< Safety Features:
<   --dry-run       Preview changes without committing (appends instruction to prompt)
<   --no-monitors   Skip auto-launching monitor terminals (useful for CI/CD or headless environments)
<   --rollback [N]  Undo last N Ralph commits (default: 1). Requires confirmation.
<   --resume        Resume from last incomplete iteration (checks for uncommitted changes)
<
< OpenCode Options:
<   --opencode-serve      Start local OpenCode server for faster runs (implies --opencode-attach localhost:4096)
<   --opencode-port N     Port for OpenCode server (default: 4096)
<   --opencode-attach <url> Attach to running OpenCode server at <url> (e.g., http://localhost:4096)
<   --opencode-format default|json  Format for OpenCode output (default: default; use default for grep-based verifiers)
<
< Examples:
<   # Run BUILD once (from anywhere)
<   bash ralph/loop.sh --prompt ralph/PROMPT_build.md --iterations 1 --plan-every 999
<
<   # From inside ralph/
<   bash ./loop.sh --prompt ./PROMPT_build.md --iterations 1 --plan-every 999
<
<   # Alternate plan/build for 10 iters, plan every 3
<   bash ralph/loop.sh --iterations 10 --plan-every 3
<
<   # Use Sonnet model for faster iterations
<   bash ralph/loop.sh --model sonnet --iterations 20 --plan-every 5
<
<   # Use Opus for careful planning
<   bash ralph/loop.sh --model opus --iterations 1
<
<   # Dry-run mode (see what would change)
<   bash ralph/loop.sh --dry-run --iterations 1
<
<   # Run without monitor terminals (useful for CI/CD)
<   bash ralph/loop.sh --no-monitors --iterations 5
<
<   # Rollback last 2 iterations
<   bash ralph/loop.sh --rollback 2
<
<   # Resume after error
<   bash ralph/loop.sh --resume
< EOF
< }
<
< # Defaults
< ITERATIONS=1
< PLAN_EVERY=3
< YOLO_FLAG="--yolo"
< RUNNER="rovodev"
< PROMPT_ARG=""
< BRANCH_ARG=""
< DRY_RUN=false
< OPENCODE_SERVE=false
< OPENCODE_PORT=4096
< OPENCODE_ATTACH=""
< OPENCODE_FORMAT="default"
< ROLLBACK_MODE=false
< ROLLBACK_COUNT=1
< RESUME_MODE=false
< NO_MONITORS=false
<
< # Parse args
< while [[ $# -gt 0 ]]; do
<   case "$1" in
<     --prompt)
<       PROMPT_ARG="${2:-}"; shift 2 ;;
<     --iterations)
<       ITERATIONS="${2:-}"; shift 2 ;;
<     --plan-every)
<       PLAN_EVERY="${2:-}"; shift 2 ;;
<     --yolo)
<       YOLO_FLAG="--yolo"; shift ;;
<     --no-yolo)
<       YOLO_FLAG=""; shift ;;
<     --runner)
<       RUNNER="${2:-}"; shift 2 ;;
<     --opencode-serve)
<       OPENCODE_SERVE=true; shift ;;
<     --opencode-port)
<       OPENCODE_PORT="${2:-4096}"; shift 2 ;;
<     --opencode-attach)
<       OPENCODE_ATTACH="${2:-}"; shift 2 ;;
<     --opencode-format)
<       OPENCODE_FORMAT="${2:-default}"; shift 2 ;;
<     --model)
<     --branch)
<       BRANCH_ARG="${2:-}"; shift 2 ;;
<     --dry-run)
<       DRY_RUN=true; shift ;;
<     --no-monitors)
<       NO_MONITORS=true; shift ;;
<     --rollback)
<       ROLLBACK_MODE=true
<       if [[ -n "${2:-}" && "$2" =~ ^[0-9]+$ ]]; then
<         ROLLBACK_COUNT="$2"; shift 2
<       else
<         shift
<       fi ;;
<     --resume)
<       RESUME_MODE=true; shift ;;
<     -h|--help)
<       usage; exit 0 ;;
<     *)
<       echo "Unknown arg: $1" >&2
<       usage; exit 2 ;;
<   esac
< done
<
< # Model version configuration - SINGLE SOURCE OF TRUTH
< # Update these when new model versions are released
< # Last updated: 2026-01-18 (Sonnet 4.5 September 2025 release)
<
< # Resolve model shortcut to full model ID
< resolve_model() {
<   local model="$1"
<   case "$model" in
<     opus|opus4.5|opus45)
<     sonnet|sonnet4.5|sonnet45)
<     sonnet4)
<     latest|auto)
<       # Use system default - don't override config
<       echo "" ;;
<     *)
<       echo "$model" ;;
<   esac
< }
<
< # Resolve model shortcut to OpenCode provider/model.
< # IMPORTANT: Replace placeholder IDs below with the *exact* IDs from: opencode models
< resolve_model_opencode() {
<   local model="$1"
<   case "$model" in
<     grok|grokfast|grok-code-fast-1)
<       # Confirmed via opencode models
<       echo "opencode/grok-code" ;;
<     opus|opus4.5|opus45)
<       # Placeholder - anthropic not available in current setup
<       echo "opencode/gpt-5-nano" ;;  # Fallback to available model
<     sonnet|sonnet4.5|sonnet45)
<       # Placeholder - anthropic not available
<       echo "opencode/gpt-5-nano" ;;  # Fallback
<     latest|auto)
<       # Let OpenCode decide its own default if user explicitly asked for auto/latest
<       echo "" ;;
<     *)
<       # Pass through (user provided provider/model already, or an OpenCode alias)
<       echo "$model" ;;
<   esac
< }
<
< # Setup model config - default to Sonnet 4.5 for Ralph loops
< CONFIG_FLAG=""
< TEMP_CONFIG=""
<
< # Use provided model or default based on runner
<   if [[ "$RUNNER" == "opencode" ]]; then
<   else
<   fi
< fi
<
< if [[ "$RUNNER" == "opencode" ]]; then
< else
< fi
<
< # Only create RovoDev temp config when runner=rovodev and we have a model to set
< if [[ "$RUNNER" == "rovodev" ]]; then
<   if [[ -n "$RESOLVED_MODEL" ]]; then
<     TEMP_CONFIG="/tmp/rovodev_config_$$_$(date +%s).yml"
<
<     # Copy base config and override modelId
<     if [[ -f "$HOME/.rovodev/config.yml" ]]; then
<       sed "s|^  modelId:.*|  modelId: $RESOLVED_MODEL|" "$HOME/.rovodev/config.yml" > "$TEMP_CONFIG"
<     else
<       cat > "$TEMP_CONFIG" <<EOFCONFIG
< version: 1
< agent:
<   modelId: $RESOLVED_MODEL
< EOFCONFIG
<     fi
<     CONFIG_FLAG="--config-file $TEMP_CONFIG"
<     echo "Using model: $RESOLVED_MODEL"
<   fi
< else
<   # OpenCode runner uses provider/model directly; no temp config needed.
<   if [[ -n "$RESOLVED_MODEL" ]]; then
<     echo "Using model: $RESOLVED_MODEL"
<   else
<     echo "Using model: (OpenCode default)"
<   fi
< fi
<
< # Resolve target branch:
< # 1. User-provided --branch takes precedence
< # 2. On --resume without --branch, stay on current branch
< # 3. Otherwise use default WORK_BRANCH
< if [[ -n "$BRANCH_ARG" ]]; then
<   TARGET_BRANCH="$BRANCH_ARG"
< elif [[ "$RESUME_MODE" == "true" ]]; then
<   TARGET_BRANCH="$(git -C "$ROOT" rev-parse --abbrev-ref HEAD 2>/dev/null || echo "$WORK_BRANCH")"
< else
<   TARGET_BRANCH="$WORK_BRANCH"
< fi
<
< # Debug output for derived values
< echo "Repo: $REPO_NAME | Branch: $TARGET_BRANCH | Lock: $LOCK_FILE"
<
< # Resolve a prompt path robustly (works from repo root or ralph/)
< resolve_prompt() {
<   local p="$1"
<   if [[ -z "$p" ]]; then return 1; fi
<
<   # 1) As provided (relative to current working directory)
<   if [[ -f "$p" ]]; then
<     realpath "$p"
<     return 0
<   fi
<
<   # 2) Relative to repo root
<   if [[ -f "$ROOT/$p" ]]; then
<     realpath "$ROOT/$p"
<     return 0
<   fi
<
<   echo "Prompt not found: $p (checked: '$p' and '$ROOT/$p')" >&2
<   return 1
< }
<
< # Handle rollback mode
< if [[ "$ROLLBACK_MODE" == "true" ]]; then
<   echo "========================================"
<   echo "ðŸ”„ Rollback Mode"
<   echo "========================================"
<   echo ""
<
<   # Show last N commits
<   echo "Last $ROLLBACK_COUNT commit(s) to be reverted:"
<   echo ""
<   git log --oneline -n "$ROLLBACK_COUNT"
<   echo ""
<
<   # Confirmation
<   read -p "âš ï¸  Revert these $ROLLBACK_COUNT commit(s)? (type 'yes' to confirm): " confirm
<   if [[ "$confirm" != "yes" ]]; then
<     echo "Rollback cancelled."
<     exit 0
<   fi
<
<   # Perform rollback
<   echo ""
<   echo "Reverting last $ROLLBACK_COUNT commit(s)..."
<   if git reset --hard HEAD~"$ROLLBACK_COUNT"; then
<     echo "âœ… Rollback successful!"
<     echo ""
<     echo "Current HEAD:"
<     git log --oneline -n 1
<   else
<     echo "âŒ Rollback failed!"
<     exit 1
<   fi
<
<   exit 0
< fi
<
< # Handle resume mode
< if [[ "$RESUME_MODE" == "true" ]]; then
<   echo "========================================"
<   echo "ðŸ”„ Resume Mode"
<   echo "========================================"
<   echo ""
<
<   # Check for uncommitted changes
<   if git diff --quiet && git diff --cached --quiet; then
<     echo "No uncommitted changes found."
<     echo "Nothing to resume. Repository is clean."
<     exit 0
<   fi
<
<   echo "Uncommitted changes detected:"
<   echo ""
<   git status --short
<   echo ""
<
<   read -p "Continue from this state? (yes/no): " confirm
<   if [[ "$confirm" != "yes" ]]; then
<     echo "Resume cancelled."
<     exit 0
<   fi
<
<   echo "âœ… Continuing with existing changes..."
<   echo ""
< fi
<
< # Handle branch switching
< if [[ -n "$BRANCH_ARG" ]]; then
<   CURRENT_BRANCH=$(git branch --show-current)
<   if [[ "$CURRENT_BRANCH" != "$BRANCH_ARG" ]]; then
<     echo "========================================"
<     echo "ðŸŒ¿ Branch: $BRANCH_ARG"
<     echo "========================================"
<
<     # Check if branch exists
<     if git show-ref --verify --quiet "refs/heads/$BRANCH_ARG"; then
<       git checkout "$BRANCH_ARG"
<     else
<       echo "Creating new branch: $BRANCH_ARG"
<       git checkout -b "$BRANCH_ARG"
<       # Push if remote exists
<       if git remote get-url origin &>/dev/null; then
<         git push -u origin "$BRANCH_ARG" 2>/dev/null || true
<       fi
<     fi
<     echo ""
<   fi
< fi
<
< # Ralph determines mode from iteration number (PROMPT.md has conditional logic)
< PLAN_PROMPT="$RALPH/PROMPT.md"
< BUILD_PROMPT="$RALPH/PROMPT.md"
<
< # Verifier gate - runs rules/AC.rules checks after BUILD
< VERIFY_SCRIPT="$RALPH/verifier.sh"
< RUN_ID_FILE="$RALPH/.verify/run_id.txt"
< INIT_SCRIPT="$RALPH/init_verifier_baselines.sh"
<
< # Auto-init verifier baselines if missing
< init_verifier_if_needed() {
<   if [[ -x "$INIT_SCRIPT" && ! -f "$AC_HASH_FILE" ]]; then
<     echo ""
<     echo "========================================"
<     echo "ðŸ”§ Initializing verifier baselines..."
<     echo "========================================"
<     if "$INIT_SCRIPT"; then
<       echo "âœ… Baselines initialized successfully"
<     else
<       echo "âŒ Failed to initialize baselines"
<       return 1
<     fi
<   fi
<   return 0
< }
<
< # Track last verifier result for prompt injection
< LAST_VERIFIER_STATUS=""
< LAST_VERIFIER_FAILED_RULES=""
< LAST_VERIFIER_FAIL_COUNT=0
<
< # Parse verifier report to extract failed rules
< parse_verifier_failures() {
<   local report_file="$1"
<   [[ -f "$report_file" ]] || return
<
<   local rules=""
<   local count=0
<
<   # Extract [FAIL] rule IDs (standard format)
<   local standard_fails
<   standard_fails=$(grep -oE '^\[FAIL\] [A-Za-z0-9_.]+' "$report_file" 2>/dev/null | sed 's/\[FAIL\] //' | tr '\n' ',' | sed 's/,$//' | sed 's/,,*/,/g')
<   local standard_count
<   standard_count=$(grep -c '^\[FAIL\]' "$report_file" 2>/dev/null || echo "0")
<
<   # Check for hash guard failure (special format: [timestamp] FAIL: AC hash mismatch)
<   if grep -q 'FAIL: AC hash mismatch' "$report_file" 2>/dev/null; then
<     rules="HashGuard"
<     count=1
<   fi
<
<   # Combine results
<   if [[ -n "$standard_fails" ]]; then
<     if [[ -n "$rules" ]]; then
<       rules="$rules, $standard_fails"
<     else
<       rules="$standard_fails"
<     fi
<     count=$((count + standard_count))
<   fi
<
<   LAST_VERIFIER_FAILED_RULES="$rules"
<   LAST_VERIFIER_FAIL_COUNT="$count"
< }
<
< # Check if Ralph requested human intervention in the log
< check_human_intervention() {
<   local log_file="$1"
<   # Strip ANSI codes and check for human intervention marker
<   if sed 's/\x1b\[[0-9;]*m//g' "$log_file" | grep -q 'HUMAN INTERVENTION REQUIRED'; then
<     return 0  # intervention needed
<   fi
<   return 1  # no intervention needed
< }
<
< # Check if previous verifier found protected file failures (requires human intervention)
< check_protected_file_failures() {
<   # If no failed rules, nothing to check
<   [[ -z "$LAST_VERIFIER_FAILED_RULES" ]] && return 1
<
<   # Check if any Protected.* rules failed
<   if echo "$LAST_VERIFIER_FAILED_RULES" | grep -qE 'Protected\.[0-9]+'; then
<     return 0  # protected file failures found
<   fi
<   return 1  # no protected file failures
< }
<
< run_verifier() {
<   if [[ ! -x "$VERIFY_SCRIPT" ]]; then
<     echo "âš ï¸  Verifier not found or not executable: $VERIFY_SCRIPT"
<     LAST_VERIFIER_STATUS="SKIP"
<     return 0  # Don't block if verifier doesn't exist yet
<   fi
<
<   # Auto-init baselines if missing
<   if ! init_verifier_if_needed; then
<     LAST_VERIFIER_STATUS="FAIL"
<     LAST_VERIFIER_FAILED_RULES="init_baselines"
<     LAST_VERIFIER_FAIL_COUNT=1
<     return 1
<   fi
<
<   echo ""
<   echo "========================================"
<   echo "ðŸ” Running acceptance criteria verifier..."
<   echo "========================================"
<
<   # Generate unique run ID for freshness check
<   RUN_ID="$(date +%s)-$$"
<   export RUN_ID
<
<   if "$VERIFY_SCRIPT"; then
<     # Verify freshness: run_id.txt must match our RUN_ID
<     if [[ -f "$RUN_ID_FILE" ]]; then
<       local stored_id
<       stored_id=$(cat "$RUN_ID_FILE" 2>/dev/null)
<       if [[ "$stored_id" != "$RUN_ID" ]]; then
<         echo "âŒ Freshness check FAILED: run_id mismatch"
<         echo "   Expected: $RUN_ID"
<         echo "   Got: $stored_id"
<         LAST_VERIFIER_STATUS="FAIL"
<         LAST_VERIFIER_FAILED_RULES="freshness_check"
<         LAST_VERIFIER_FAIL_COUNT=1
<         return 1
<       fi
<     else
<       echo "âŒ Freshness check FAILED: run_id.txt not found"
<       LAST_VERIFIER_STATUS="FAIL"
<       LAST_VERIFIER_FAILED_RULES="freshness_check"
<       LAST_VERIFIER_FAIL_COUNT=1
<       return 1
<     fi
<
<     echo "âœ… All acceptance criteria passed! (run_id: $RUN_ID)"
<     cat "$RALPH/.verify/latest.txt" 2>/dev/null | tail -10 || true
<     LAST_VERIFIER_STATUS="PASS"
<     LAST_VERIFIER_FAILED_RULES=""
<     LAST_VERIFIER_FAIL_COUNT=0
<     return 0
<   else
<     echo "âŒ Acceptance criteria FAILED"
<     echo ""
<     cat "$RALPH/.verify/latest.txt" 2>/dev/null || echo "(no report found)"
<     LAST_VERIFIER_STATUS="FAIL"
<     parse_verifier_failures "$RALPH/.verify/latest.txt"
<     return 1
<   fi
< }
<
< run_once() {
<   local prompt_file="$1"
<   local phase="$2"
<   local iter="$3"
<
<   local ts
<   ts="$(date +%F_%H%M%S)"
<   local log="$LOGDIR/${ts}_iter${iter}_${phase}.log"
<
<   echo
<   echo "========================================"
<   echo "Ralph Loop"
<   echo "Root: $ROOT"
<   echo "Iteration: $iter / $ITERATIONS"
<   echo "Phase: $phase"
<   echo "Prompt: $prompt_file"
<   echo "Log: $log"
<   echo "========================================"
<   echo
<
<   # Create temporary prompt with mode prepended
<   local prompt_with_mode="/tmp/rovodev_prompt_with_mode_$$_${iter}.md"
<   {
<     echo "# MODE: ${phase^^}"
<     echo ""
<
<     # Inject verifier status from previous iteration (if any)
<     if [[ -n "$LAST_VERIFIER_STATUS" ]]; then
<       echo "# LAST_VERIFIER_RESULT: $LAST_VERIFIER_STATUS"
<       if [[ "$LAST_VERIFIER_STATUS" == "FAIL" ]]; then
<         echo "# FAILED_RULES: $LAST_VERIFIER_FAILED_RULES"
<         echo "# FAILURE_COUNT: $LAST_VERIFIER_FAIL_COUNT"
<         echo "# ACTION_REQUIRED: Read .verify/latest.txt and fix AC failures BEFORE picking new tasks."
<       fi
<       echo ""
<     fi
<
<     cat "$prompt_file"
<
<     # Append dry-run instruction if enabled
<     if [[ "$DRY_RUN" == "true" ]]; then
<       echo ""
<       echo "---"
<       echo ""
<       echo "# DRY-RUN MODE ACTIVE"
<       echo ""
<       echo "âš ï¸ **CRITICAL: This is a dry-run. DO NOT commit any changes.**"
<       echo ""
<       echo "Your task:"
<       echo "1. Read IMPLEMENTATION_PLAN.md and identify the first unchecked task"
<       echo "2. Analyze what changes would be needed to implement it"
<       echo "3. Show file diffs or describe modifications you would make"
<       echo "4. Update IMPLEMENTATION_PLAN.md with detailed notes about your findings"
<       echo "5. DO NOT use git commit - stop after analysis"
<       echo ""
<       echo "Output format:"
<       echo "- List files that would be created/modified"
<       echo "- Show code snippets or diffs for key changes"
<       echo "- Document any risks or dependencies discovered"
<       echo "- Add findings to IMPLEMENTATION_PLAN.md under 'Discoveries & Notes'"
<       echo ""
<       echo "This is a preview only. No commits will be made."
<     fi
<   } > "$prompt_with_mode"
<
<   # Feed prompt into selected runner
<   if [[ "$RUNNER" == "opencode" ]]; then
<     # NOTE: Passing full prompt as CLI arg can hit shell/argv limits if prompt is huge.
<     # If that happens, pivot to a file-based approach after validating basic integration.
<     attach_flag=""
<     if [[ -n "${OPENCODE_ATTACH:-}" ]]; then
<       attach_flag="--attach ${OPENCODE_ATTACH}"
<     fi
<     opencode run ${attach_flag} --model "${RESOLVED_MODEL}" --format "${OPENCODE_FORMAT}" "$(cat "$prompt_with_mode")" 2>&1 | tee "$log"
<     rc=$?
<     if [[ $rc -ne 0 ]]; then
<       echo "âŒ OpenCode failed (exit $rc). See: $log"
<       tail -n 80 "$log" || true
<       return 1
<     fi
<   else
<     # Default: RovoDev
<     script -q -c "cat \"$prompt_with_mode\" | acli rovodev run ${CONFIG_FLAG} ${YOLO_FLAG}" "$log"
<   fi
<
<   # Clean up temporary prompt
<   rm -f "$prompt_with_mode"
<
<   echo
<   echo "Run complete."
<   echo "Transcript: $log"
<
<   # In dry-run mode, remind user no commits were made
<   if [[ "$DRY_RUN" == "true" ]]; then
<     echo ""
<     echo "========================================"
<     echo "ðŸ” Dry-run completed"
<     echo "No changes were committed."
<     echo "Review the transcript above for analysis."
<     echo "========================================"
<   fi
<
<
<   # Run verifier after both PLAN and BUILD iterations
<   if [[ "$phase" == "plan" ]] || [[ "$phase" == "build" ]]; then
<     if run_verifier; then
<       echo ""
<       echo "========================================"
<       echo "ðŸŽ‰ ${phase^^} iteration verified successfully!"
<       echo "========================================"
<     else
<       echo ""
<       echo "========================================"
<       echo "âš ï¸  ${phase^^} completed but verification failed."
<       echo "Review .verify/latest.txt for details."
<       echo "========================================"
<     fi
<   fi
<
<   # Legacy: also check for :::COMPLETE::: but ignore it (loop.sh owns completion now)
<   if sed 's/\x1b\[[0-9;]*m//g' "$log" | grep -qE '^\s*:::COMPLETE:::\s*$'; then
<     echo ""
<     echo "âš ï¸  Ralph output :::COMPLETE::: but that token is reserved for loop.sh."
<     echo "Ignoring - use :::BUILD_READY::: or :::PLAN_READY::: instead."
<   fi
<
<   # Check if Ralph requested human intervention
<   if check_human_intervention "$log"; then
<     echo ""
<     echo "========================================"
<     echo "ðŸ›‘ HUMAN INTERVENTION REQUIRED"
<     echo "========================================"
<     echo "Ralph has indicated it cannot proceed without human help."
<     echo "Review the log above for details."
<     echo ""
<     return 43  # Special return code for human intervention
<   fi
<
<   # Check if all tasks are done (for true completion)
<   if [[ -f "$RALPH/IMPLEMENTATION_PLAN.md" ]]; then
<     local unchecked_count
<     # Note: grep -c returns exit 1 when count is 0, so we capture output first then default
<     unchecked_count=$(grep -cE '^\s*-\s*\[ \]' "$RALPH/IMPLEMENTATION_PLAN.md" 2>/dev/null) || unchecked_count=0
<     if [[ "$unchecked_count" -eq 0 ]]; then
<       # All tasks done - run final verification
<       if run_verifier; then
<         echo ""
<         echo "========================================"
<         echo "ðŸŽ‰ All tasks complete and verified!"
<         echo "========================================"
<         return 42  # Special return code for completion
<       fi
<     fi
<   fi
<
<   return 0
< }
<
< # Launch a script in a new terminal window
< # Args: $1 = window title, $2 = script path, $3 = process grep pattern
< # Returns: 0 if launched successfully, 1 otherwise
< launch_in_terminal() {
<   local title="$1"
<   local script_path="$2"
<   local process_pattern="$3"
<
<   # Try to detect available terminal emulator (priority order: tmux, wt.exe, gnome-terminal, konsole, xterm)
<   # All terminal launches redirect stderr to /dev/null to suppress dbus/X11 errors
<   if [[ -n "${TMUX:-}" ]]; then
<     if tmux new-window -n "$title" "bash $script_path" 2>/dev/null; then
<       return 0
<     fi
<   elif command -v wt.exe &>/dev/null; then
<     wt.exe new-tab --title "$title" -- wsl bash "$script_path" 2>/dev/null &
<     sleep 0.5
<     if pgrep -f "$process_pattern" > /dev/null; then
<       return 0
<     fi
<   elif command -v gnome-terminal &>/dev/null; then
<     gnome-terminal --title="$title" -- bash "$script_path" 2>/dev/null &
<     sleep 0.5  # Give it time to fail
<     if pgrep -f "$process_pattern" > /dev/null; then
<       return 0
<     fi
<   elif command -v konsole &>/dev/null; then
<     konsole --title "$title" -e bash "$script_path" 2>/dev/null &
<     sleep 0.5
<     if pgrep -f "$process_pattern" > /dev/null; then
<       return 0
<     fi
<   elif command -v xterm &>/dev/null; then
<     xterm -T "$title" -e bash "$script_path" 2>/dev/null &
<     sleep 0.5
<     if pgrep -f "$process_pattern" > /dev/null; then
<       return 0
<     fi
<   fi
<
<   return 1
< }
<
< # Auto-launch monitors in background if not already running
< launch_monitors() {
<   local monitor_dir="$RALPH"
<   local current_tasks_launched=false
<   local thunk_tasks_launched=false
<
<   # Check if current_ralph_tasks.sh exists and launch
<   if [[ -f "$monitor_dir/current_ralph_tasks.sh" ]]; then
<     if ! pgrep -f "current_ralph_tasks.sh" > /dev/null; then
<       if launch_in_terminal "Current Tasks" "$monitor_dir/current_ralph_tasks.sh" "current_ralph_tasks.sh"; then
<         current_tasks_launched=true
<       fi
<     else
<       current_tasks_launched=true  # Already running
<     fi
<   fi
<
<   # Check if thunk_ralph_tasks.sh exists and launch
<   if [[ -f "$monitor_dir/thunk_ralph_tasks.sh" ]]; then
<     if ! pgrep -f "thunk_ralph_tasks.sh" > /dev/null; then
<       if launch_in_terminal "Thunk Tasks" "$monitor_dir/thunk_ralph_tasks.sh" "thunk_ralph_tasks.sh"; then
<         thunk_tasks_launched=true
<       fi
<     else
<       thunk_tasks_launched=true  # Already running
<     fi
<   fi
<
<   # If both monitors failed to launch, print consolidated fallback message
<   if [[ "$current_tasks_launched" == "false" && "$thunk_tasks_launched" == "false" ]]; then
<     echo ""
<     echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
<     echo "  âš ï¸  Could not auto-launch monitor terminals."
<     echo ""
<     echo "  To run monitors manually, open new terminals and run:"
<     echo "    bash $monitor_dir/current_ralph_tasks.sh"
<     echo "    bash $monitor_dir/thunk_ralph_tasks.sh"
<     echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
<     echo ""
<    fi
< }
<
< # Start OpenCode server if requested
< if [[ "$RUNNER" == "opencode" ]]; then
<   if $OPENCODE_SERVE; then
<     OPENCODE_ATTACH="http://localhost:${OPENCODE_PORT}"
<     opencode serve --port "$OPENCODE_PORT" >/tmp/opencode_serve.log 2>&1 &
<     OPENCODE_SERVE_PID=$!
<     trap '[[ -n "${OPENCODE_SERVE_PID:-}" ]] && kill "$OPENCODE_SERVE_PID" 2>/dev/null' EXIT
<   fi
< fi
<
< # Fail fast if opencode runner but command not found
< if [[ "$RUNNER" == "opencode" ]]; then
<   command -v opencode >/dev/null 2>&1 || { echo "ERROR: opencode not found in PATH"; exit 1; }
< fi
<
< # Health check for attach endpoint (TCP port check)
< if [[ -n "${OPENCODE_ATTACH:-}" ]]; then
<   hostport="${OPENCODE_ATTACH#http://}"
<   hostport="${hostport#https://}"
<   hostport="${hostport%%/*}"
<   h="${hostport%%:*}"
<   p="${hostport##*:}"
<   if ! (echo > /dev/tcp/"$h"/"$p") >/dev/null 2>&1; then
<     echo "WARN: OpenCode attach endpoint not reachable; running without --attach"
<     OPENCODE_ATTACH=""
<   fi
< fi
<
< # Print effective config for debugging
< echo "Runner=${RUNNER} Model=${RESOLVED_MODEL:-<default>} Format=${OPENCODE_FORMAT:-<default>} Attach=${OPENCODE_ATTACH:-<none>} Serve=${OPENCODE_SERVE:-false}"
<
< # Ensure we're on the worktree branch before starting
< echo ""
< echo "========================================"
< echo "Setting up worktree branch: $TARGET_BRANCH"
< echo "========================================"
< ensure_worktree_branch "$TARGET_BRANCH"
< echo ""
<
< # Launch monitors before starting iterations (unless --no-monitors flag is set)
< if [[ "$NO_MONITORS" == "false" ]]; then
<   launch_monitors
< fi
<
< # Determine prompt strategy
< if [[ -n "$PROMPT_ARG" ]]; then
<   PROMPT_FILE="$(resolve_prompt "$PROMPT_ARG")"
<   for ((i=1; i<=ITERATIONS; i++)); do
<     # Check for interrupt before starting iteration
<     if [[ "$INTERRUPT_RECEIVED" == "true" ]]; then
<       echo ""
<       echo "Exiting gracefully after iteration $((i-1))."
<       exit 130
<     fi
<
<     # Check for protected file failures before starting LLM (requires human intervention)
<     if check_protected_file_failures; then
<       echo ""
<       echo "========================================"
<       echo "ðŸ›‘ HUMAN INTERVENTION REQUIRED"
<       echo "========================================"
<       echo "Protected file hash mismatches detected: $LAST_VERIFIER_FAILED_RULES"
<       echo ""
<       echo "These files are protected and cannot be fixed by Ralph."
<       echo ""
<       # Show which specific files failed
<       if [[ -f "$VERIFY_REPORT" ]]; then
<         echo "Failed protected files:"
<         grep "^\[FAIL\] Protected\." "$VERIFY_REPORT" | while read -r line; do
<           if echo "$line" | grep -q "Protected.1"; then
<             echo "  - loop.sh"
<           elif echo "$line" | grep -q "Protected.2"; then
<             echo "  - verifier.sh"
<           elif echo "$line" | grep -q "Protected.3"; then
<             echo "  - PROMPT.md"
<           elif echo "$line" | grep -q "Protected.4"; then
<             echo "  - rules/AC.rules"
<           fi
<         done
<         echo ""
<       fi
<       echo "To regenerate baselines for these files:"
<       echo "  cd brain/ralph"
<       echo ""
<       echo "After resolving, re-run the loop to continue."
<       exit 1
<     fi
<
<     # Capture exit code without triggering set -e
<     run_result=0
<     run_once "$PROMPT_FILE" "custom" "$i" || run_result=$?
<     # Check if Ralph signaled completion
<     if [[ $run_result -eq 42 ]]; then
<       echo ""
<       echo "Loop terminated early due to completion."
<       break
<     fi
<     # Check if Ralph requested human intervention
<     if [[ $run_result -eq 43 ]]; then
<       echo ""
<       echo "Loop paused - human intervention required."
<       echo "After resolving the issue, re-run the loop to continue."
<       exit 1
<     fi
<   done
< else
<   # Alternating plan/build
<   for ((i=1; i<=ITERATIONS; i++)); do
<     # Check for interrupt before starting iteration
<     if [[ "$INTERRUPT_RECEIVED" == "true" ]]; then
<       echo ""
<       echo "Exiting gracefully after iteration $((i-1))."
<       exit 130
<     fi
<
<     # Check for protected file failures before starting LLM (requires human intervention)
<     if check_protected_file_failures; then
<       echo ""
<       echo "========================================"
<       echo "ðŸ›‘ HUMAN INTERVENTION REQUIRED"
<       echo "========================================"
<       echo "Protected file hash mismatches detected: $LAST_VERIFIER_FAILED_RULES"
<       echo ""
<       echo "These files are protected and cannot be fixed by Ralph."
<       echo ""
<       # Show which specific files failed
<       if [[ -f "$VERIFY_REPORT" ]]; then
<         echo "Failed protected files:"
<         grep "^\[FAIL\] Protected\." "$VERIFY_REPORT" | while read -r line; do
<           if echo "$line" | grep -q "Protected.1"; then
<             echo "  - loop.sh"
<           elif echo "$line" | grep -q "Protected.2"; then
<             echo "  - verifier.sh"
<           elif echo "$line" | grep -q "Protected.3"; then
<             echo "  - PROMPT.md"
<           elif echo "$line" | grep -q "Protected.4"; then
<             echo "  - rules/AC.rules"
<           fi
<         done
<         echo ""
<       fi
<       echo "To regenerate baselines for these files:"
<       echo "  cd brain/ralph"
<       echo ""
<       echo "After resolving, re-run the loop to continue."
<       exit 1
<     fi
<
<     # Capture exit code without triggering set -e
<     run_result=0
<     if [[ "$i" -eq 1 ]] || (( PLAN_EVERY > 0 && ( (i-1) % PLAN_EVERY == 0 ) )); then
<       run_once "$PLAN_PROMPT" "plan" "$i" || run_result=$?
<     else
<       run_once "$BUILD_PROMPT" "build" "$i" || run_result=$?
<     fi
<     # Check if Ralph signaled completion (exit code 42)
<     if [[ $run_result -eq 42 ]]; then
<       echo ""
<       echo "Loop terminated early due to completion."
<       break
<     fi
<     # Check if Ralph requested human intervention (exit code 43)
<     if [[ $run_result -eq 43 ]]; then
<       echo ""
<       echo "Loop paused - human intervention required."
<       echo "After resolving the issue, re-run the loop to continue."
<       exit 1
<     fi
<   done
< fi
differ'
[WARN] Hygiene.Markdown.1 (auto check in warn gate)
  desc: No duplicate H2 headings in IMPLEMENTATION_PLAN.md
  cmd:  grep -E '^## ' IMPLEMENTATION_PLAN.md | sort | uniq -d | wc -l | tr -d ' '
  exit: 0
  stdout: 0
[WARN] Hygiene.Markdown.2 (auto check in warn gate)
  desc: No code fences without language tags in AGENTS.md
  cmd:  grep -cE '^```$' AGENTS.md 2>/dev/null || true
  exit: 0
  stdout: 0
[WARN] Hygiene.Markdown.3 (auto check in warn gate)
  desc: No code fences without language tags in THOUGHTS.md
  cmd:  grep -cE '^```$' THOUGHTS.md 2>/dev/null || true
  exit: 0
  stdout: 0
[WARN] Hygiene.Markdown.4 (auto check failed but warn gate)
  desc: No code fences without language tags in NEURONS.md
  cmd:  grep -cE '^```$' NEURONS.md 2>/dev/null || true
  exit: 0
  stdout: 1
  reasons:
    - stdout mismatch expected='0' got='1'
[WARN] Hygiene.DocSync.1 (auto check in warn gate)
  desc: AGENTS.md THUNK monitor docs don't reference removed 'f' hotkey
  cmd:  grep -A5 'THUNK Monitor' AGENTS.md | grep -c 'force sync\|f.*sync' 2>/dev/null || true
  exit: 0
  stdout: 0
[WARN] Hygiene.DocSync.2 (auto check in warn gate)
  desc: AGENTS.md THUNK monitor docs don't claim auto-sync
  cmd:  grep -A10 'THUNK Monitor' AGENTS.md | grep -c 'Auto-sync\|auto-sync' 2>/dev/null || true
  exit: 0
  stdout: 0
[WARN] Hygiene.StatusSync.1 (auto check in warn gate)
  desc: IMPLEMENTATION_PLAN.md has no conflicting branch status claims
  cmd:  bash -c 'up=$(grep -c "up to date" IMPLEMENTATION_PLAN.md 2>/dev/null || echo 0); ahead=$(grep -c "commits ahead" IMPLEMENTATION_PLAN.md 2>/dev/null || echo 0); if [[ $up -gt 0 && $ahead -gt 0 ]]; then echo "conflict"; else echo "ok"; fi'
  exit: 0
  stdout: ok
[WARN] Hygiene.Structure.1 (auto check in warn gate)
  desc: NEURONS.md skills/ file count is accurate (currently 23+ files)
  cmd:  bash -c 'actual=$(find skills/ -type f -name "*.md" 2>/dev/null | wc -l); claimed=$(grep -oE "skills/[^)]*\([0-9]+ files\)" NEURONS.md 2>/dev/null | grep -oE "[0-9]+" | head -1 || echo 0); if [[ $claimed -lt 20 && $actual -gt 20 ]]; then echo "outdated"; else echo "ok"; fi'
  exit: 0
  stdout: ok
[WARN] Waiver.CountLimit (auto check in warn gate)
  desc: No more than 10 active waivers (keep exceptions exceptional)
  cmd:  bash -c 'source ../.verify/check_waiver.sh 2>/dev/null && count=$(count_active_waivers); if [[ $count -le 10 ]]; then echo "ok ($count active)"; else echo "FAIL: $count active waivers (max 10)"; fi'
  exit: 0
  stdout: ok (4 active)
[PASS] Waiver.NoBlanketScope
  desc: No waivers with wildcard or repo-wide scope
  cmd:  bash -c 'found=0; shopt -s nullglob; for f in ../.verify/waivers/*.approved; do [[ -f "$f" ]] || continue; if grep -qE "PATHS=(\.|(\*)+|.*\*.*)" "$f"; then found=1; echo "FAIL: $(basename "$f") has wildcard scope"; fi; done; [[ $found -eq 0 ]] && echo "ok"'
  exit: 0
  stdout: ok
[PASS] Waiver.ExpiryRequired
  desc: All approved waivers have valid EXPIRES field
  cmd:  bash -c 'shopt -s nullglob; for f in ../.verify/waivers/*.approved; do [[ -f "$f" ]] || continue; exp=$(grep "^EXPIRES=" "$f" | cut -d= -f2); if [[ -z "$exp" ]]; then echo "FAIL: $(basename "$f") missing EXPIRES"; exit 1; fi; done; echo "ok"'
  exit: 0
  stdout: ok
[PASS] Waiver.HashIntegrity
  desc: Approved waivers match their request hashes (no tampering)
  cmd:  bash -c 'shopt -s nullglob; for f in ../.verify/waivers/*.approved; do [[ -f "$f" ]] || continue; wid=$(grep "^WAIVER_ID=" "$f" | cut -d= -f2); req="../.verify/waiver_requests/${wid}.json"; stored=$(grep "^REQUEST_SHA256=" "$f" | cut -d= -f2); if [[ -f "$req" ]]; then actual=$(sha256sum "$req" | cut -d" " -f1); if [[ "$stored" != "$actual" ]]; then echo "FAIL: ${wid} hash mismatch (request modified after approval)"; exit 1; fi; fi; done; echo "ok"'
  exit: 0
  stdout: ok
[WARN] Waiver.NoUnapprovedInUse (auto check in warn gate)
  desc: No waiver requests referenced without corresponding approval
  cmd:  bash -c 'shopt -s nullglob; for req in ../.verify/waiver_requests/*.json; do [[ -f "$req" ]] || continue; wid=$(basename "$req" .json); if [[ ! -f "../.verify/waivers/${wid}.approved" ]]; then echo "PENDING: $wid (not yet approved)"; fi; done; echo "ok"'
  exit: 0
  stdout: ok
[WARN] Cortex.FileSizeLimit.THOUGHTS (auto check in warn gate)
  desc: cortex/THOUGHTS.md max 100 lines (archive old content)
  cmd:  bash -c 'lines=$(wc -l < ../../cortex/THOUGHTS.md 2>/dev/null || echo 0); [[ $lines -le 100 ]] && echo "ok ($lines lines)" || echo "OVER: $lines lines (max 100)"'
  exit: 0
  stdout: ok (39 lines)
[WARN] Cortex.FileSizeLimit.SYSTEM_PROMPT (auto check in warn gate)
  desc: cortex/CORTEX_SYSTEM_PROMPT.md max 150 lines
  cmd:  bash -c 'lines=$(wc -l < ../../cortex/CORTEX_SYSTEM_PROMPT.md 2>/dev/null || echo 0); [[ $lines -le 150 ]] && echo "ok ($lines lines)" || echo "OVER: $lines lines (max 150)"'
  exit: 0
  stdout: ok (82 lines)
[WARN] Cortex.FileSizeLimit.AGENTS (auto check failed but warn gate)
  desc: cortex/AGENTS.md max 150 lines
  cmd:  bash -c 'lines=$(wc -l < ../../cortex/AGENTS.md 2>/dev/null || echo 0); [[ $lines -le 150 ]] && echo "ok ($lines lines)" || echo "OVER: $lines lines (max 150)"'
  exit: 0
  stdout: OVER: 156 lines (max 150)
  reasons:
    - stdout regex mismatch expected=/^ok/ got='OVER: 156 lines (max 150)'
------------------------------------------------------------
SUMMARY
  PASS: 23
  FAIL: 1
  WARN: 28 (manual_warn=2)
  SKIP: 0
  Manual gate=block failures: 0
  Hash guard: OK
